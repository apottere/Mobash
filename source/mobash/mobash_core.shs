#!/bin/bash

#@import print.ln

#@import resolve.dir
#@import resolve.file_in_path

#@import arrays.init
#@import arrays.len
#@import arrays.set
#@import arrays.index_of
#@import arrays.dump

#@import dict.init
#@import dict.dump
#@import dict.set
#@import dict.get_index_array
#@import dict.get_keys
#@import dict.get

#@import error.do
#@import error.file
#@import error.format
#@import error.exit

mobash_finalize() {

	echo
	print_ln "%-${FORMAT_WIDTH}s" "Finalizing script " $YEL
	echo 'mo_main "$@"' >> $BIN_NEW
	if [[ $PRESERVE_TEMP_FILES ]]; then
		cp $BIN_NEW $BIN
	else
		mv $BIN_NEW $BIN
	fi
	chmod 755 $BIN
	echo -e "$RS${GRN}Complete$RS"
	mobash_cleanup
}

mobash_cleanup() {
	print_ln "%-${FORMAT_WIDTH}s" "Cleaning up files " $YEL
	echo -e "$RS${GRN}Complete$RS"
	if [[ -z $PRESERVE_TEMP_FILES ]]; then
		rm $BIN_NEW &>/dev/null
		rm $SOURCE_FILE_CUSTOM &>/dev/null
	fi
	exit 0
}

mobash_resolve_function_for_file() {
	file=$1
	func=$2
	print_ln "%-${FORMAT_WIDTH}s" "    $func(): " $MGT; echo -n -e "$RED"
	bash -c 'source '$file'; if [[ $(declare -f '$func') == "" ]]; then exit 1; else declare -f '$func' | grep -v \"^$\" >> '$BIN_NEW'; fi'

	if [[ $? == 1 ]]; then
		echo -e "No valid function declaration found.$RS"
		echo
		mobash_cleanup
	else
		echo -e "$RS${GRN}Complete$RS"
	fi
}

# $1: Root for tree (source file name)
mobash_resolve_imports() {
	echo -e "${YEL}Building dependency list...$RS"

	dict_init MOBASH_IMPORTS

	local include; unset IFS
	for include in $(dict_get_keys INCLUDE_FILES)
	do
		local absolute="$(dict_get INCLUDE_FILES $include)"
		print_ln "%-${FORMAT_WIDTH}s" "  $include: " $CYN
		echo -e "${LGRN}$absolute$RS"

		local import; unset IFS
		for import in $(grep "^#@import" "$absolute" | awk '{ print $2 }' | sort | uniq)
		do
			mobash_insert_import "$import" "$absolute"
		done
	done

	dict_dump MOBASH_IMPORTS

	declare -a mobash_imports_searched
	unset MOBASH_IMPORT_FILES
	mobash_imports_needed="true"
	while [[ $mobash_imports_needed ]]; do
		mobash_imports_needed=""

		# for all imports in array
		for MOBASH_IMPORTS_N in "${!MOBASH_IMPORTS_I[@]}"; do
			mobash_import="${MOBASH_IMPORTS_I[$MOBASH_IMPORTS_N]}"

			# only do unsearched imports
			if [[ ! "${mobash_imports_searched[$MOBASH_IMPORTS_N]}" ]]; then
				mobash_imports_searched[$MOBASH_IMPORTS_N]="true"
				print_ln "%-${FORMAT_WIDTH}s" "  $mobash_import: " $CYN
				mobash_module=`echo -n "$mobash_import" | sed 's/\..*//'`

				# if no file in map, find the file for that function.
				if [[ ! $(mobash_get_file_map_index $mobash_module) ]]; then
					mobash_module_file=$(resolve_file_in_path "$mobash_module.shm" "$IMPORT_PATH" ":")
					if [[ ! $mobash_module_file ]]; then
						echo -e "${RED}No file found in path for: $mobash_module$RS"
						mobash_cleanup
					fi
					MOBASH_IMPORT_FILES_I[${#MOBASH_IMPORT_FILES[@]}]="$mobash_module"
					MOBASH_IMPORT_FILES[${#MOBASH_IMPORT_FILES[@]}]="$mobash_module_file"
				fi
				echo -e "${LGRN}${MOBASH_IMPORT_FILES[`mobash_get_file_map_index $mobash_module`]}$RS"


				# get imports for specific function from it's module file
				mobash_function_imports=`grep "^#@function $mobash_import:" "${MOBASH_IMPORT_FILES[$mobash_module]}" | awk -F': ' '{print $2}'`

				# if there are imports, add add them to the array if they're new
				if [[ $mobash_function_imports ]]; then

					BIFS="$IFS"
					IFS=' '
					for mobash_function_import in $mobash_function_imports; do

						if mobash_insert_import "$mobash_function_import" "${MOBASH_IMPORTS[$MOBASH_IMPORTS_N]}->$mobash_module"; then
							mobash_imports_needed="true"
						fi
					done
					IFS="$BIFS"
				fi
			fi

		done
	done

}

mobash_insert_import() {
	if [[ "$1" ]]; then
		print_ln "%-$(( $FORMAT_WIDTH + 2 ))s" "    $1: " $MGT

		local current="$(dict_get MOBASH_IMPORTS "$1")"
		if [[ $current ]]; then
			echo -e "${LYEL}$current$RS"
			return 1
		else
			echo -e "${GRN}New dependency$RS"
			dict_set MOBASH_IMPORTS "$1" "$2"
			return 0
		fi
	fi
}

mobash_get_file_map_index() {
	for mobash_file_map_index in "${!MOBASH_IMPORT_FILES_I[@]}"
	do
		if [[ "${MOBASH_IMPORT_FILES_I[$mobash_file_map_index]}" == "$1" ]]; then
#			echo "found: "$mobash_file_map_index 1>&2
			echo $mobash_file_map_index
			return
#		else
#			echo "${MOBASH_IMPORT_FILES_I[$mobash_file_map_index]} is not $1" 1>&2
		fi
	done
}

mobash_transfer_import_contents() {
	echo -e "\n${YEL}Writing imports...$RS"
	mobash_transfer_current=""
	BIFS="$IFS"
	IFS=$'\n'
	for mobash_import_s in `sort <<< "${MOBASH_IMPORTS_I[*]}"`; do
		IFS="$BIFS"
		declare -a mobash_transfer_parts=(${mobash_import_s/./ })

		if [[ ${mobash_transfer_parts[0]} != $mobash_transfer_current ]]; then
			if ! mobash_transfer_queued_contents; then
				mobash_cleanup
			fi

			mobash_transfer_current="${mobash_transfer_parts[0]}"
			unset mobash_transfer_names; declare -a mobash_transfer_names
		fi
#		echo "Adding '${mobash_transfer_parts[1]}' to array."
		mobash_transfer_names[${#mobash_transfer_names[@]}]="${mobash_transfer_parts[1]}"
		IFS=$'\n'
	done
	IFS="$BIFS"

	if ! mobash_transfer_queued_contents; then
		mobash_cleanup
	fi
}

mobash_transfer_queued_contents() {
	if [[ $mobash_transfer_current ]]; then
		print_ln "%-${FORMAT_WIDTH}s" "  $mobash_transfer_current: " $CYN
		echo -n -e "$RED"
		(
		if source ${MOBASH_IMPORT_FILES[`mobash_get_file_map_index $mobash_transfer_current`]};
		then
			echo -e "$LGRN${MOBASH_IMPORT_FILES[`mobash_get_file_map_index $mobash_transfer_current`]}"
			for mobash_transfer_name in ${mobash_transfer_names[@]};
			do 
				print_ln "%-$(( $FORMAT_WIDTH + 2 ))s" "    $mobash_transfer_name: " $MGT
				declare -f "${mobash_transfer_current}_$mobash_transfer_name" >> $BIN_NEW
				echo -e "${GRN}Complete$RS"
			done
		else
			return 1
		fi
		)
	fi
}

# $1: Source filename
mobash_get_filenames() {

	# Source
	print_ln "%-${FORMAT_WIDTH}s" "Resolving source " $YEL

	SOURCE_FILE=$(resolve_file_in_path "$1.shs" "$SOURCE_PATH" ":")


	if [[ ! $SOURCE_FILE ]]; then
		echo -e "${RED}No source found in path for: $1.shs$RS"
		exit 1
	fi
	SOURCE_FILE_CUSTOM="$SOURCE_FILE.custom"

	echo -e "${LGRN}$SOURCE_FILE$RS"

	echo -e "${YEL}Finding includes...$RS"
	dict_init INCLUDE_FILES

	dict_set INCLUDE_FILES "$1.shs" "$SOURCE_FILE"

	local include_file include_absolute_file

	unset IFS
	for include_file in $(grep "^#@include" "$SOURCE_FILE" | awk '{ print $2 }')
	do
		print_ln "%-${FORMAT_WIDTH}s" "  $include_file: " $CYN
		include_absolute_file=$(resolve_file_in_path "$include_file" "$INCLUDE_PATH" ":")
		if [[ $include_absolute_file ]]; then
			dict_set INCLUDE_FILES "$include_file" "$include_absolute_file"

			echo -e "${LGRN}$include_absolute_file$RS"
		else
			echo
			dict_dump INCLUDE_FILES
			echo -e "\n${RED}No source file in path for: $include_file$RS"
			mobash_cleanup
		fi
	done

	# Config
	CONFIG_FILE=$(cat $SOURCE_FILE | grep "^#@config" | head -1 | awk '{ print $2 }')
	if [[ $CONFIG_FILE ]]; then
		echo
		print_ln "%-${FORMAT_WIDTH}s" "Resolving config " $YEL
		local temp_config_file=$(resolve_file_in_path "$CONFIG_FILE" "$CONFIG_PATH" ":")

		if [[ $temp_config_file ]]; then
			CONFIG_FILE="$temp_config_file"
			echo -e "${LGRN}$temp_config_file$RS"
		else
			echo -e "${RED}No config found in path for: $temp_config_file$RS"
			exit 1
		fi
	fi

	# Output
	print_ln "%-${FORMAT_WIDTH}s" "Resolving output " $YEL
	BIN="$(resolve_dir $BIN_DIR)/$1$BIN_EXTENSION"
	BIN_NEW="$BIN.new"
	echo -e "${LGRN}$BIN$RS"

}

mobash_get_custom_contents() {

	echo -e "\n${YEL}Collecting custom...$RS"

	echo "mo_main() {" > $SOURCE_FILE_CUSTOM

	local i f
	for (( i=${#INCLUDE_ABSOLUTE_FILES[@]}-1 ; i>=0 ; i-- )) ; do

		f=${INCLUDE_ABSOLUTE_FILES[$i]}
		print_ln "%-${FORMAT_WIDTH}s" "  $f: " $CYN
		cat "$f" >> $SOURCE_FILE_CUSTOM
		echo >> $SOURCE_FILE_CUSTOM
		echo -e "${GRN}Complete$RS"
	done

	echo "}" >> $SOURCE_FILE_CUSTOM

	print_ln "%-${FORMAT_WIDTH}s" "Writing custom " $YEL
	echo -n -e "$RED"
	if mobash_apply_custom_contents; then
		echo -e "$RS${GRN}Complete$RS"
	else
		echo -e -n "$RS"
		echo
		mobash_cleanup
	fi

}

mobash_apply_custom_contents() {
	(
		if source $SOURCE_FILE_CUSTOM; then
			declare -f mo_main >> $BIN_NEW
		else
			return 1
		fi
	)
}


mobash_init_bin() {
	echo "#!/bin/bash" > $BIN_NEW
	echo -e "# Compiled with MoBash v$MOBASH_VERSION\n" >> $BIN_NEW

	if [[ $CONFIG_FILE ]]; then
		cat "$CONFIG_FILE" >> $BIN_NEW
	fi

	echo -e "\n################################################################################" >> $BIN_NEW
	echo "# GENERATED CODE" >> $BIN_NEW
	echo "################################################################################" >> $BIN_NEW

}

mobash_usage() {
	cat <<EOT

usage: mobash [options] <binary>                    Compile <binary> from sources.
   or: mobash [options] <binary> -r [args ..]       Compile <binary> and run it with [args ..]

Arguments:
   -sh                       Append .sh to the compiled binary
   -p, --preserve            Leave .custom and .new files in place after exit

EOT
}
